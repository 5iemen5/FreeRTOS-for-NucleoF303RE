/*
 * CLI_commands.c
 *
 *  Created on: Sep 23, 2025
 *      Author: user
 */

#include "CLI_commands.h"
#include "MISC.h"				//Contains additional functions like Blink
#include <stdlib.h>				//For atol()


const CLI_Command_Definition_t vBlink = {
		"blink",
		"\r\nblink <delay_ms>:\r\n Simple blink of LD2 with settable delay in milliseconds\r\n",
		xBlink_CLI,
		1
};

extern bool RX_CB_happened;
TaskHandle_t xCLI_Handle = NULL;
uint8_t cRxedChar = 0;


BaseType_t xBlink_CLI(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString){
	BaseType_t xParameterLength = 0;
	BaseType_t xBlinkDelay = 1000;
	char * pcReturnPar = NULL;

	//Parameter parse. Only 1 param in this function - the delay for LED
	pcReturnPar = FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParameterLength);

	//Terminate the returned string. Super important!
	pcReturnPar[xParameterLength] = 0x00;

	//Fetch integer from user parameter string
	if(pcReturnPar != NULL){
		xBlinkDelay = atol(pcReturnPar);
	}else{

	}

	//Output buffer, transmitted after command execution. First needs cleared.
	memset(pcWriteBuffer, 0, xWriteBufferLen);
	strncpy(pcWriteBuffer, "Blink called!\r\n", xWriteBufferLen);

	//Call to BLINK() itself
	BLINK(xBlinkDelay);
	return 0;
}


/*===========================GENERAL READING========================*/

void CLI_read(void *pvParameters){
	const uint32_t MAX_INPUT_LENGTH = 50;
	const uint32_t MAX_OUTPUT_LENGTH = 100;

	uint8_t cInputIndex = 0;
	BaseType_t xMoreDataToFollow;
	static char pcOutputString[ 100 ], pcInputString[ 50 ];

	xCLI_Handle = xTaskGetCurrentTaskHandle();			//Store the handle of the current task

	static const char * const  pcWelcomeMessage =
	  "FreeRTOS command server\r\nType Help to view a list of registered commands\r\nNote: Enter is performed by \\n not \\r\\n\r\n ";

	HAL_UART_Transmit(&huart2, (const uint8_t *)pcWelcomeMessage, strlen(pcWelcomeMessage), 40);

	if(HAL_NVIC_GetActive(USART2_IRQn) != 1){
		HAL_NVIC_EnableIRQ(USART2_IRQn);
	}

	HAL_UART_Receive_IT(&huart2, &cRxedChar, sizeof(cRxedChar));						//Non blocking.

	for( ; ; ){


			if (ulTaskNotifyTake(pdTRUE, portMAX_DELAY) == pdTRUE)
			{


				HAL_UART_Receive(&huart2, &cRxedChar, sizeof(cRxedChar), HAL_MAX_DELAY);				//Blocking

				/*============IF NEWLINE============*/
				if( cRxedChar == '\n' ){

					//!!!RX_CB_happened = 0;														//Clear the CB marker, cuz cmd is complete and we're gonna interpret it

					HAL_UART_Transmit(&huart2, (const uint8_t *)"\r\n", strlen("\r\n"), 40);

					do
					{
						/* Send the command string to the command interpreter. Any
						   output generated by the command interpreter will be placed in the
						   pcOutputString buffer. */
						xMoreDataToFollow = FreeRTOS_CLIProcessCommand
									  (
										  pcInputString,   /* The command string.*/
										  pcOutputString,  /* The output buffer. */
										  MAX_OUTPUT_LENGTH/* The size of the output buffer. */
									  );

						/* Write the output generated by the command interpreter to the
						   console. */



						HAL_UART_Transmit(&huart2, (const uint8_t *)pcOutputString, strlen(pcOutputString), 40);

					} while( xMoreDataToFollow != pdFALSE );

					/* All the strings generated by the input command have been sent.
					   Processing of the command is complete. Clear the input string ready
					   to receive the next command. */

					cInputIndex = 0;
					memset( pcInputString, 0x00, MAX_INPUT_LENGTH );

				}
				/*==================================*/
				else{
					if( cRxedChar == '\r' )
					{
						/* Ignore carriage returns. */
					}
					else if( cRxedChar == '\b' )
					{
						/* Backspace was pressed. Erase the last character in the input
						   buffer - if there are any. */
						if( cInputIndex > 0 )
						{
							cInputIndex--;
							pcInputString[ cInputIndex ] = 0;
						}
					}
					else
					{
						/* A character was entered. It was not a new line, backspace
						   or carriage return, so it is accepted as part of the input and
						   placed into the input buffer. When a n is entered the complete
						   string will be passed to the command interpreter. */
						if( cInputIndex < MAX_INPUT_LENGTH )
						{
							pcInputString[ cInputIndex ] = cRxedChar;
							cInputIndex++;
						}
					}


				}
			}
		}
}
